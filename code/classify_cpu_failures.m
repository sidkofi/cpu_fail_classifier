% CLASSIFY_CPU_FAILURES - Main script for CPU Failure Classification Project
%
% Description:
%   This script performs the following steps:
%   1. Loads simulated CPU benchmark data.
%   2. Defines parameters for preprocessing and feature extraction.
%   3. Iterates through each run in the dataset.
%   4. Preprocesses the frequency data (filtering).
%   5. Performs wavelet decomposition.
%   6. Extracts key features (Peak Count, Magnitude Ratio, Separated Distance, MAD).
%   7. Applies a rule-based classification logic using thresholds on the features.
%   8. Calculates and displays the overall accuracy and a confusion matrix.
%   9. Optionally generates visualizations for analysis (commented out by default).
%
% Requires:
%   - MATLAB Wavelet Toolbox
%   - benchmark_data.csv (generated by generate_cpu_benchmark_data.m)
%   - load_benchmark_data.m (helper function)
%
% Author: Sidney Taylor

clear; clc; close all; % Start with a clean environment

%% 1. Load Existing Data
fprintf('--- CPU Failure Classification Script ---\n');
try
    % Load data into table and cell array
    [data, run_data_cell_optional] = load_benchmark_data('benchmark_data.csv');
    % For this script structure, we primarily use the 'data' table
    num_total_runs = max(data.Run_ID); % Get total number of runs
    fprintf('Loaded data for %d runs.\n', num_total_runs);
catch ME
    error('Failed to load benchmark data. Ensure benchmark_data.csv exists and load_benchmark_data.m is accessible. Error: %s', ME.message);
end

%% 2. Define Parameters

% --- Preprocessing Parameters ---
Fs = 10;            % Sampling frequency (Hz) - MUST match data generation
ma_window = 3;      % Moving average window size
butter_order = 2;   % Butterworth filter order
butter_cutoff = 3.0;% Butterworth cutoff frequency (Hz)

% --- Wavelet Parameters ---
wavelet_name = 'db4'; % Wavelet family to use
num_levels = 6;     % Number of decomposition levels
detail_level = 1;   % Focus feature extraction on Detail Level 1

% --- Feature Extraction Parameters ---
% For Significant Peak Count (Feature 1)
peak_height_factor_sig = 1.5; % MinPeakHeight = factor * std(abs(D1)) - Adjusted based on project evolution
peak_dist_sec_sig = 0.2;      % MinPeakDistance in seconds for counting peaks

% For Magnitude Ratio (Feature 2) - Window around peaks to exclude from 'rest' average
peak_exclude_window_samples = 5;

% For Separated Peak Distance (Feature 3)
min_dist_for_feature_sec = 3.0; % Min separation required (seconds)
min_peak_height_factor_for_dist = 1.5; % Factor for finding candidate peaks for distance

% --- Classification Thresholds (FINAL - based on user tuning) ---
threshold_mad_max_for_none = 0.0006;
threshold_pk_count_min_for_none = 40; % Condition used alongside MAD for 'None'
threshold_freq_osc_min_peak_count = 6;
threshold_freq_osc_max_ratio = 20.0;
threshold_mad_min_for_freq_osc = 0.00065; % Lower bound MAD for Freq Osc
threshold_thermal_min_ratio_final = 39;
threshold_mad_min_for_thermal = 0.002; % Lower bound MAD for Thermal

fprintf('Parameters set. Fs=%.1f, MA_Win=%d, Butterworth=(%d, %.1fHz), Wavelet=%s(%d)\n', ...
        Fs, ma_window, butter_order, butter_cutoff, wavelet_name, num_levels);
fprintf('Classification Thresholds: MAD_None<%.4f, PkCnt_None>%d, PkCnt_Osc>%d, Ratio_Osc<%.1f, MAD_Osc>%.5f, Ratio_Therm>%.0f, MAD_Therm>%.3f\n', ...
        threshold_mad_max_for_none, threshold_pk_count_min_for_none, threshold_freq_osc_min_peak_count, ...
        threshold_freq_osc_max_ratio, threshold_mad_min_for_freq_osc, threshold_thermal_min_ratio_final, threshold_mad_min_for_thermal);

%% 3. Extract Features and Classify for Each Run

% Initialize storage
% Features: [PeakCount, MagRatio, PeakDistSeparated, MeanAbsDev]
num_features = 4;
new_features = NaN(num_total_runs, num_features); % Use NaN for runs with errors
true_failure_types = cell(num_total_runs, 1);
predicted_failure_types = cell(num_total_runs, 1);

fprintf('Processing %d runs...\n', num_total_runs);
tic; % Start timer

for i = 1:num_total_runs % Loop through each Run ID
    run_id = i;
    run_indices = data.Run_ID == run_id;
    run_subset = data(run_indices, :);

    if isempty(run_subset)
        warning('Run ID %d has no data in the table. Skipping.', run_id);
        true_failure_types{i} = 'Invalid_Data';
        predicted_failure_types{i} = 'Invalid_Data';
        continue;
    end

    % Get true label (use first entry for the run)
    true_failure_types{i} = char(run_subset.Failure_Type(1));

    % Extract time and frequency data for this run
    time_data = run_subset.Time;
    raw_freq_data = run_subset.Frequency_GHz;
    n_samples = length(time_data);

    % Basic data validity check
    if isempty(time_data) || isempty(raw_freq_data) || length(time_data) ~= length(raw_freq_data) || all(isnan(raw_freq_data)) || n_samples < ma_window || n_samples < butter_order*3
         warning('Invalid or insufficient data for Run ID %d (%s). Skipping feature extraction.', run_id, true_failure_types{i});
         true_failure_types{i} = 'Invalid_Data'; % Mark as invalid if data is bad
         predicted_failure_types{i} = 'Invalid_Data';
         continue;
    end

    % --- Preprocessing ---
    freq_ma = movmean(raw_freq_data, ma_window, 'omitnan');
    [b_filt, a_filt] = butter(butter_order, butter_cutoff/(Fs/2));
    freq_data = filtfilt(b_filt, a_filt, freq_ma); % Filtered data

    % --- Wavelet Decomposition & D1 Reconstruction ---
    try
        [c, l] = wavedec(freq_data, num_levels, wavelet_name);
        detail_recon = wrcoef('d', c, l, wavelet_name, detail_level); % D1
        abs_detail_recon = abs(detail_recon);
    catch ME_wavelet
        warning('Wavelet analysis failed for Run ID %d (%s). Error: %s Skipping.', run_id, true_failure_types{i}, ME_wavelet.message);
        true_failure_types{i} = 'Invalid_Data';
        predicted_failure_types{i} = 'Invalid_Data';
        continue;
    end

    % --- Feature Calculation ---
    try
        % Feature 1: Significant Peak Count
        min_peak_h_sig = peak_height_factor_sig * std(abs_detail_recon);
        min_peak_d_samples_sig = round(peak_dist_sec_sig * Fs);
        if min_peak_d_samples_sig < 1, min_peak_d_samples_sig = 1; end
        [pks_sig, ~] = findpeaks(abs_detail_recon, 'MinPeakHeight', min_peak_h_sig, 'MinPeakDistance', min_peak_d_samples_sig);
        pk_count = length(pks_sig);

        % Feature 2: Top 2 Peak Magnitude Ratio (Global Peaks)
        [pks_top_global, locs_top_global] = findpeaks(abs_detail_recon, 'SortStr', 'descend', 'NPeaks', 2);
        mag_ratio = 0; % Default
        if ~isempty(pks_top_global)
            mask = true(n_samples, 1);
            for p = 1:length(pks_top_global)
                 current_loc = locs_top_global(p);
                 if current_loc > 0 && current_loc <= n_samples
                    win_start = max(1, current_loc - peak_exclude_window_samples);
                    win_end = min(n_samples, current_loc + peak_exclude_window_samples);
                    mask(win_start:win_end) = false;
                 end
            end
            if any(mask)
                avg_rest_mag = mean(abs_detail_recon(mask));
                if avg_rest_mag > 1e-9
                     mag_ratio = mean(pks_top_global) / avg_rest_mag;
                else
                     mag_ratio = mean(pks_top_global) / (1e-9);
                end
            else
                mag_ratio = Inf; % Indicate invalid if mask removed all
            end
        end

        % Feature 3: Top 2 Peak Distance *with Minimum Separation*
        pk_dist_sep = 0; % Default
        min_peak_h_dist = min_peak_height_factor_for_dist * std(abs_detail_recon);
        min_dist_samples = round(min_dist_for_feature_sec * Fs);
        if min_dist_samples < 1, min_dist_samples = 1; end
        [pks_all_dist, locs_all_dist] = findpeaks(abs_detail_recon, 'MinPeakHeight', min_peak_h_dist, 'SortStr', 'descend');
        if length(pks_all_dist) >= 2
            first_peak_loc = locs_all_dist(1);
            for j = 2:length(pks_all_dist)
                second_peak_loc_candidate = locs_all_dist(j);
                if abs(second_peak_loc_candidate - first_peak_loc) >= min_dist_samples
                    pk_dist_sep = abs(second_peak_loc_candidate - first_peak_loc) / Fs;
                    break;
                end
            end
        end

        % Feature 4: Mean Absolute Deviation (MAD)
        mad_val = 0; % Default
        if n_samples > 0 && ~all(isnan(abs_detail_recon))
            mean_abs_d1 = mean(abs_detail_recon);
            mad_val = mean(abs(abs_detail_recon - mean_abs_d1));
        end

        % Store Features
        new_features(i, :) = [pk_count, mag_ratio, pk_dist_sep, mad_val];

    catch ME_feature
        warning('Feature extraction failed for Run ID %d (%s). Error: %s Skipping.', run_id, true_failure_types{i}, ME_feature.message);
        true_failure_types{i} = 'Invalid_Data';
        predicted_failure_types{i} = 'Invalid_Data';
        continue; % Skip classification if features failed
    end

    % --- Classification Logic ---
    % Apply rules based on extracted features
    if mad_val < threshold_mad_max_for_none && pk_count > threshold_pk_count_min_for_none
        predicted_failure_types{i} = 'None';
    elseif pk_count > threshold_freq_osc_min_peak_count && mag_ratio < threshold_freq_osc_max_ratio && mad_val > threshold_mad_min_for_freq_osc
        predicted_failure_types{i} = 'Frequency_Oscillation';
    elseif mag_ratio > threshold_thermal_min_ratio_final && mad_val > threshold_mad_min_for_thermal
        predicted_failure_types{i} = 'Thermal_Throttling';
    else
        predicted_failure_types{i} = 'Stuck_Frequency';
    end

    % Optional: Progress update
    if mod(i, 100) == 0
        fprintf('  Processed run %d/%d\n', i, num_total_runs);
    end

end % End of loop through runs
toc; % Stop timer
fprintf('Feature extraction and classification complete.\n');

%% 4. Calculate and Display Accuracy

fprintf('\n--- Evaluating Classification Results ---\n');

% Remove any runs marked as 'Invalid_Data' during processing
valid_indices = ~strcmp(true_failure_types, 'Invalid_Data');
true_labels_valid = true_failure_types(valid_indices);
predicted_labels_valid = predicted_failure_types(valid_indices);
num_valid_runs = length(true_labels_valid);

if num_valid_runs == 0
    error('No valid runs found after processing. Cannot calculate accuracy.');
end
fprintf('Evaluating on %d valid runs.\n', num_valid_runs);

% Overall Accuracy
correct_predictions = strcmp(true_labels_valid, predicted_labels_valid);
overall_accuracy = sum(correct_predictions) / num_valid_runs;

fprintf('Overall Accuracy: %.2f%%\n', overall_accuracy * 100);

% Confusion Matrix
% Define the expected order of labels for consistency
class_order = {'None', 'Frequency_Oscillation', 'Stuck_Frequency', 'Thermal_Throttling'};
% Ensure both true and predicted labels are categorical with the same order
true_cat = categorical(true_labels_valid, class_order);
pred_cat = categorical(predicted_labels_valid, class_order);

figure('Name', 'Confusion Matrix');
cm = confusionchart(true_cat, pred_cat);
cm.Title = sprintf('CPU Failure Classification (Overall Acc: %.2f%%)', overall_accuracy * 100);
cm.ColumnSummary = 'column-normalized'; % Show precision
cm.RowSummary = 'row-normalized';     % Show recall

% Display text version (optional)
% C = confusionmat(true_cat, pred_cat, 'Order', class_order);
% fprintf('\nConfusion Matrix (Rows: True, Columns: Predicted):\n');
% fprintf('Labels: %s\n', strjoin(class_order, ', '));
% disp(C);

fprintf('\n--- Classification Report Complete ---\n');

%% 5. Optional Visualizations (Uncomment to Run)
% These sections generate plots shown in the blog post/presentation.
% They require the 'example_runs' struct to be defined, which maps
% failure type names to specific Run IDs. You might need to run the
% example selection code first if running this section independently.

% --- Define Example Runs (Manually or using the provided code) ---
% fprintf('\n--- Defining Example Runs for Visualization ---\n');
% try
%     failure_types_unique = categories(unique(categorical(true_labels_valid))); % Get unique valid types
%     example_runs = struct();
%     for i = 1:length(failure_types_unique)
%         type = failure_types_unique{i};
%         % Find the first valid run index corresponding to this type
%         idx_in_valid = find(strcmp(true_labels_valid, type), 1);
%         if ~isempty(idx_in_valid)
%             original_run_indices = find(valid_indices); % Map valid index back to original run ID
%             example_runs.(type) = original_run_indices(idx_in_valid);
%             fprintf('Selected Run ID %d as example for %s\n', example_runs.(type), type);
%         else
%             warning('Could not find a valid example run for type: %s', type);
%         end
%     end
% catch ME_example
%     warning('Could not automatically define example runs. Error: %s', ME_example.message);
%     disp('Define example_runs struct manually if needed for plots.');
%     % Example manual definition:
%     % example_runs.None = 14;
%     % example_runs.Thermal_Throttling = 6;
%     % example_runs.Frequency_Oscillation = 9;
%     % example_runs.Stuck_Frequency = 1;
% end
%
% % --- Plot Example Raw Signals ---
% if exist('example_runs', 'var')
%     fprintf('\n--- Plotting one example run per failure type (in separate figures) ---\n');
%     failure_types_to_plot = fieldnames(example_runs)';
%     num_types = length(failure_types_to_plot);
%     for i = 1:num_types
%         current_type_str = failure_types_to_plot{i};
%         example_run_id = example_runs.(current_type_str);
%         run_subset = data(data.Run_ID == example_run_id, :);
%         if isempty(run_subset) || ~ismember('Time', run_subset.Properties.VariableNames) || ~ismember('Frequency_GHz', run_subset.Properties.VariableNames)
%             warning('Example run %d (%s) invalid for plotting raw signal.', example_run_id, current_type_str); continue; end
%         min_freq_run = min(run_subset.Frequency_GHz); max_freq_run = max(run_subset.Frequency_GHz);
%         y_padding = (max_freq_run - min_freq_run) * 0.05; if y_padding == 0, y_padding = 0.1; end
%         ylim_dynamic = [min_freq_run - y_padding, max_freq_run + y_padding];
%         figure('Name', sprintf('Example Raw: %s', current_type_str), 'Position', [100 + (i-1)*40, 100 + (i-1)*40, 600, 400]);
%         plot(run_subset.Time, run_subset.Frequency_GHz, 'LineWidth', 1.5); grid on; box on;
%         ylim(ylim_dynamic); title(strrep(current_type_str,'_',' '), 'FontSize', 12);
%         xlabel('Time (s)', 'FontSize', 10); ylabel('Frequency (GHz)', 'FontSize', 10); set(gca, 'FontSize', 10);
%         fprintf('Plotted raw example for %s (Run ID: %d).\n', current_type_str, example_run_id);
%     end
% end
%
% % --- Plot Filter Responses ---
% fprintf('\n--- Plotting Filter Responses ---\n');
% % Moving Average
% figure('Name','Filter Response: Moving Average'); clf;
% ma_coeffs = ones(1, ma_window) / ma_window; [h_ma, w_ma] = freqz(ma_coeffs, 1, 1024); f_ma = w_ma/(2*pi) * Fs;
% plot(f_ma, 20*log10(abs(h_ma)), 'LineWidth', 2); title('Frequency Response'); xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)'); grid on; box on; xlim([0, Fs/2]); ylim([-30, 5]);
% ma_params_str = sprintf('Window Size: %d', ma_window);
% annotation('textbox', [0.75, 0.8, 0.1, 0.1], 'String', ma_params_str, 'EdgeColor', 'none', 'HorizontalAlignment', 'center', 'FitBoxToText', 'on');
% % Butterworth
% figure('Name','Filter Response: Butterworth'); clf;
% [b, a] = butter(butter_order, butter_cutoff/(Fs/2)); [h_butter, w_butter] = freqz(b, a, 1024); f_butter = w_butter/(2*pi) * Fs;
% plot(f_butter, 20*log10(abs(h_butter)), 'LineWidth', 2); title('Frequency Response'); xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)'); grid on; box on; xlim([0, Fs/2]); ylim([-30, 5]);
% butter_params_str = sprintf('Order: %d Cutoff: %.1f Hz', butter_order, butter_cutoff);
% annotation('textbox', [0.75, 0.8, 0.1, 0.1], 'String', butter_params_str, 'EdgeColor', 'none', 'HorizontalAlignment', 'center', 'FitBoxToText', 'on');
%
% % --- Plot Wavelet Functions ---
% fprintf('\n--- Plotting Wavelet Functions ---\n');
% iterations = 8;
% try
%     [phi, psi, xval] = wavefun(wavelet_name, iterations);
%     figure('Name', sprintf('%s Wavelet Functions', wavelet_name), 'Position', [100, 100, 600, 350]); clf;
%     subplot(1, 2, 1); plot(xval, phi, 'LineWidth', 1.5); title('Scaling Function (\phi)'); xlabel('Time'); ylabel('Amplitude'); grid on; box on; axis tight;
%     subplot(1, 2, 2); plot(xval, psi, 'LineWidth', 1.5); title('Wavelet Function (\psi)'); xlabel('Time'); ylabel('Amplitude'); grid on; box on; axis tight;
%     sgtitle(sprintf('%s Wavelet', wavelet_name), 'FontSize', 12, 'FontWeight', 'bold');
% catch ME_wavefun
%     warning('Could not plot wavelet functions. Wavelet Toolbox installed? Error: %s', ME_wavefun.message);
% end
%
% % --- Plot D1/D2 Reconstructions ---
% if exist('example_runs', 'var')
%     fprintf('\n--- Plotting D1 and D2 reconstructions ---\n');
%     focus_levels_plot = [1, 2];
%     for field_plot = fieldnames(example_runs)'
%         type_plot = field_plot{1};
%         idx_plot = example_runs.(type_plot);
%         run_subset_plot = data(data.Run_ID == idx_plot, :);
%         if isempty(run_subset_plot) || ~ismember('Time', run_subset_plot.Properties.VariableNames) || ~ismember('Frequency_GHz', run_subset_plot.Properties.VariableNames)
%             warning('Run ID %d (%s) invalid for D1/D2 plot.', idx_plot, type_plot); continue; end
%         time_data_plot = run_subset_plot.Time; raw_freq_data_plot = run_subset_plot.Frequency_GHz;
%         if isempty(time_data_plot) || isempty(raw_freq_data_plot) || length(time_data_plot) ~= length(raw_freq_data_plot) || all(isnan(raw_freq_data_plot))
%             warning('Invalid data for Run ID %d (%s) D1/D2 plot.', idx_plot, type_plot); continue; end
%         freq_ma_plot = movmean(raw_freq_data_plot, ma_window, 'omitnan'); [b_filt_plot, a_filt_plot] = butter(butter_order, butter_cutoff/(Fs/2)); freq_data_plot = filtfilt(b_filt_plot, a_filt_plot, freq_ma_plot);
%         [c_plot, l_plot] = wavedec(freq_data_plot, num_levels, wavelet_name);
%         figure('Name', sprintf('%s - D1 vs D2', strrep(type_plot, '_', ' ')), 'Position', [100, 100, 900, 500]); clf;
%         for i_plot = 1:length(focus_levels_plot)
%             level_plot = focus_levels_plot(i_plot); subplot(2, 1, i_plot);
%             detail_recon_plot = wrcoef('d', c_plot, l_plot, wavelet_name, level_plot);
%             plot(time_data_plot, detail_recon_plot, 'LineWidth', 1.5);
%             min_peak_h_plot = std(abs(detail_recon_plot)) * 1.5; [pks_plot, locs_plot] = findpeaks(abs(detail_recon_plot), 'MinPeakHeight', min_peak_h_plot); num_peaks_plot = length(pks_plot);
%             if ~isempty(pks_plot) && ~isempty(locs_plot)
%                 valid_locs_plot = locs_plot(locs_plot <= length(time_data_plot));
%                 if ~isempty(valid_locs_plot), hold on; plot(time_data_plot(valid_locs_plot), detail_recon_plot(valid_locs_plot), 'ro', 'MarkerSize', 3, 'MarkerFaceColor', 'r'); hold off; end
%             end
%             freq_low_plot = (Fs / (2^(level_plot+1))); freq_high_plot = (Fs / (2^level_plot));
%             title(sprintf('Detail Level %d Reconstruction (Approx. %.2f-%.2f Hz)', level_plot, freq_low_plot, freq_high_plot)); ylabel('Amplitude'); grid on; box on; xlim([time_data_plot(1), time_data_plot(end)]);
%             peak_str_plot = sprintf('Peaks: %d', num_peaks_plot); text(0.98, 0.95, peak_str_plot, 'Units', 'normalized', 'HorizontalAlignment', 'right', 'VerticalAlignment', 'top', 'FontSize', 9, 'BackgroundColor', 'w','EdgeColor','k','Margin', 1);
%             if i_plot == length(focus_levels_plot), xlabel('Time (s)'); end
%         end
%         sgtitle(sprintf('Wavelet Detail Levels for %s (Run %d)', strrep(type_plot, '_', ' '), idx_plot), 'FontSize', 12, 'FontWeight', 'bold');
%         fprintf('Plotted D1/D2 for %s (Run ID: %d)\n', type_plot, idx_plot);
%     end
% end
%
% % --- Plot Feature Visualizations ---
% % (Include the individual feature visualization code blocks here if desired)
% % e.g., run the code from immersive IDs:
% % matlab_vis_pk_count
% % matlab_vis_mag_ratio (Separated Peaks version)
% % matlab_vis_sep_dist
% % matlab_vis_mad
% % Remember to ensure 'example_runs' is defined before running these.
%
% % --- Plot Classification Logic Stages ---
% % (Include the code from immersive ID: matlab_class_logic_stages here if desired)
% % Ensure thresholds are defined and data/labels are available.


fprintf('\n--- Script Finished ---\n');
